# BridgeLabz Java Summary

## Task 1: DATE: 19-01-2025
Completed Assisted Problems & Self Problems (Assignment-1)

## Task 2: DATE: 20-01-2025
- *Setting Java Environment and Classpath*
- *Installation and Setting IDE*
- *Introduction to Java - What is Java?*
  - Bytecode
  - JDK
  - JRE
  - JVM Basics
- *Main Features of JAVA:*
  - Simple
  - Object-Oriented
  - Robust
  - Platform Independent
  
- *First HelloWorld Java Program*
- *Class, Object, Method*
- *History and Evolution of Java, JVM Architecture*
- *Java Fundamentals*

## Task 3: DATE: 21-01-2025  
### 1. Static and Non-Static Members  
*Calling Static Methods:*
- From other static methods.
- From non-static methods.

*Calling Non-Static Methods:*
- From static methods.
- From other non-static methods.

## Task 4: DATE: 22-01-2025
1. *Fundamental Concepts*
   - *Comments*: Understanding the purpose and usage of comments in code.
   - *Data Types*: Exploring various data types and their applications.
   - *Variable Naming*: Learning effective strategies for naming variables.
2. *Operators and Type Conversion*
   - *Operators*: Studying different operators and their precedence.
   - *Type Conversion*: Understanding how to convert between different data types.
3. *Practice*
   - *Level 1 Problems*: Solved problems to reinforce understanding of basic concepts.

<details>
<summary>Files</summary>
- AtheleteRound.java
- AvgMarks.java
- Calculator.java
- ChocolateDistribution.java
- DiscountPrice.java
- DiscountUI.java
- DistanceConversion.java
- DividePens.java
- DoubleOperation.class
- DoubleOperation.java
- EarthVolume.java
- Handshakes.java
- HarryAge.java
- HeightConversion.java
- IntOperation.class
- IntOperation.java
- KmToMiles.java
- KmToMilesUI.java
- ProfitAndLoss.java
- QuotientAndRemainder.java
- QuotientAndReminder.class
- SimpleIntrest.java
- SquareSide.java
- SwapNumbers.class
- SwapNumbers.java
- TemperatureConversion.class
- TemperatureConversion.java
- TemperatureConversionFtoC.class
- TemperatureConversionFtoC.java
- TotalIncome.class
- TotalIncome.java
- TotalPurchasePrice.java
- TravelComputation.java
- TravelComputatuion.java
- TriangleArea.java
- WeightConversion.java
</details>

## Task 5: DATE: 23-01-2025
1. *Control Flow in Java*
   - *Java Control Flows*: Studied the flow of control in Java programs.
   - *Boolean Expressions*: Understanding the role of boolean expressions in decision-making.
   - *Conditional Statements*: Learning about if, else, and other conditional constructs.
2. *Looping and Branching*
   - *Loops*: Exploring for, while, and do-while loops.
   - *Break and Continue Statements*: Understanding their usage in controlling loop execution.
   - *Switch Statements*: Learning how to use switch statements for multi-way branching.
3. *Practice*
   - *Level 1 Problems*: Solved introductory problems to apply control flow concepts.

<details>
<summary>Files Level 1</summary>
- Bonus.java
- DivisibleByFive.java
- EveOdd.java
- FactorialFor.java
- FactorialWhile.java
- LargestNumber.java
- MultiplicationTable.java
- NumberCheck.java
- RocketCountdown.java
- RocketCountdownFor.java
- SmallestNumber.java
- SpringSeason.java
- SumOfNaturalNum.java
- SumOfnNums.java
- SumOfnNumsFor.java
- SumUntilZero.java
- SumUntilZeroOrNeg.java
- VotingEligibilityCheck.java
</details>
<details>
<summary>Files Level 2</summary>
   - *Level 2 Problems*: Tackled intermediate-level problems.
     - BMI.java
     - Factors.java
     - FizzBuzz.java
     - FizzBuzzWhile.java
     - GreatestFactor.java
     - LeapYear.java
     - LeapYearSingleIf.java
     - Multiples.java
     - PowerOfNum.java
     - PrimeNum.java
     - ResultCalculator.java
     - ThreeFriends.java
</details>
<details>
<summary>Files Level 3</summary>
   - *Level 3 Problems*: Challenged with advanced problem-solving tasks.
     - AbundantNumber.java
     - ArmstrongNumber.java
     - CountDigits.java
     - DayOfWeek.java
     - HarshadNumber.java
     - SimpleCalculator.java
</details>

## Task 6: DATE: 24-01-2025
- *Java Arrays*
  - Array Basics: Understanding how to declare, access, and modify arrays.
  - Array Length: Learning how to determine the length of an array.
  - Multidimensional Arrays: Exploring the creation and usage of multidimensional arrays.
- *Practice*
  - *Level 1 Problems*: Solved problems to reinforce understanding of array concepts.

<details>
<summary>Files Level 1</summary>
- Array2DTo1D.java
- Factors.java
- FizzBuzz.java
- MeanHeight.java
- MultiplicationTable.java
- OddEveArray.java
- PositiveNegativeCheck.java
- StoreAndSum.java
- Table.java
- VotingEligibility.java
</details>
<details>
<summary>Files Level 2</summary>
   - *Level 2 Problems*: Engaged in more complex problem-solving exercises involving arrays.
     - BMI.java
     - BMI2D.java
     - BMImulti.java
     - BonusCalculation.java
     - DigitFrequency.java
     - LargestDigits.java
     - Result.java
     - Result2D.java
     - ReverseNumber.java
     - ThreeFriends.java
</details>

## Task 7: DATE: 27-01-2025
1. *User-Defined Methods in Java*
   - Creating Methods: Understanding how to define and implement user-defined methods.
   - Reusability: Learning how to use methods multiple times to enhance code reusability.
   - Dynamic Methods: Exploring techniques to make methods more dynamic and flexible.
2. *Recursive Methods*
   - Recursion Basics: Studying the concept of recursion and how to implement recursive methods.
3. *Practice*
   - Problem Solving: Practiced problems to apply concepts of user-defined and recursive methods.
<details>
<summary>Files Level 1</summary>
AthleteRun.java
ChocolateDivision.java
HandshakeCalc.java
HandshakeCalculator.java
NaturalNumberSum.java
NumberCheck.java
QuotientAndRemainder.java
SI.java
SmallestAndLargest.java
SpringSeason.java
TrigonometricFunctions.java
WindChillCalculator.java
</details>
<details>
<summary>Files Level 2</summary>
BMICalculator.java
Factors.java
LeapYearChecker.java
NumberAnalyzer.java
Quadratic.java
RandomValues.java
StudentVoteChecker.java
SumOfNaturalNumbers.java
UnitConverte.java
UnitConverter.java
UnitConvertert.java
YoungestAndTallest.java
</details>
<details>
<summary>Files Level 3</summary>
CollinearPoints.java
FootballTeam.java
MatrixOperations.java
NumberChecker.java
NumberCheckerFour.java
NumberCheckerOne.java
NumberCheckerThree.java
NumberCheckerTwo.java
OTPGEN.java
PointDistanceAndLine.java
StudentScorecard.java
calendar.java
zara.java
</details>

## Task 8: DATE: 28-01-2025
1. *Static Methods in Java*
   - Static Methods: Understanding the characteristics and usage of static methods in Java.
   - Java Standard Library Methods: Exploring commonly used methods from the Java Standard Library.
   - Math Class: Learning about the methods available in the Math class for mathematical operations.
   - Random Class: For Generating Random Numbers.

## Task 9: DATE: 29-01-2025
- *String Handling in Java*
  - String Methods: Studied various methods available for string manipulation in Java.
  - String Handling Concepts: Explored fundamental concepts related to handling strings effectively.
  - String Problems: Solved problem statements focused on applying string methods and handling techniques.
<details>
<summary>Files Built-in Function level 1</summary>
BasicCalculator.java
FactorialRecursive.java 
FibonacciSequence.java 
GCDandLCM.java 
MaximumOfThree.java 
NumberGuess.java
PalindromeChecker.java 
PrimeNumCheck.java 
TemperatureConverter.java 
</details>
<details>
<summary>Files Built-in Function level 2</summary>
DateArithimatic.java
DateComparison.java
DateFormatting.java
TimeZone.java
</details>
<details>
<summary> Files String</summary>
AnagramCheck.java
CompareString.java
CountVowelConsonant.java
LongestWord.java
MostFrequentCharacter.java
PalindromeString.java
RemoveCharacter.java
RemoveDuplicateString.java
ReplaceWord.java
ReverseString.java
SubStringOccurrences.java
ToggleCase.java
</details>

## Task 10: DATE: 30-01-2025
- *Built-in String Methods and Exception Handling*
  - String Built-in Methods: Learned about built-in methods for string operations in Java.
  - Exception Handling: Studied the types and mechanisms of exception handling in Java.
  - *Type 1 Problems*: Solved problems using built-in functions, including date and time operations.
  - *Type 2 Problems*: Engaged in problem-solving exercises involving concepts like palindrome checks and Fibonacci sequences.

## Task 11: DATE: 31-01-2025
1. *Object-Oriented Programming (OOP) in Java*
   - OOP Overview: Gained an understanding of the principles and advantages of OOP.
   - Comparison: Compared procedural programming with object-oriented programming.
2. *Classes and Objects*
   - Java Class: Studied the structure and purpose of classes in Java.
   - Java Object: Learned about creating and using objects in Java.
3. *Practice*
   - *Level 1 Problems*: Practiced problems focusing on the application of OOP concepts, specifically classes and objects.
<details>
<summary> File OOPS 30/01 </summary>
Book.java
Circle.java
Employee.java
</details>
<details>
<summary> File OOPS 31/01 </summary>
BankAccount.java
Book.java
Book1.java
Book2.java
CarRental.java
Circle.java
Course.java
Employee.java
HotelBooking.java
Person.java
Product.java
Students.java
Vehicle.java
</details>

## Task 12: DATE: 04-02-2025
1. *this, static, final key words and instanceof operator Level 1 Lab Practice
    - this
    - static
    - final
    - instanceof operator

<details>
<summary> File this, static, final key words and instanceof operator </summary>
BankAccount.java
Book.java
Employee.java
Patient.java
Product.java
Student.java
Vehicle.java
</details>

## Task 13: DATE: 06-02-2025
1. *Submission of Object Oriented Design Principles
   Object Oriented Design Principles
   - Class Diagram
   - Object Diagrams
   - Sequence Diagrams

<details>
<summary> File Object Diagram, Sequence Diagram and Class Diagram  </summary>
ClassDiagram.jpg
SequenceDiagram.jpg
ObjectDiagram.jpg
</details>


## Task 14: DATE: 07-02-2025


- **Inheritance**: A subclass inherits the attributes and methods of a parent class.
- **Single Level Inheritance**: A subclass inherits from one parent class.
- **Multilevel Inheritance**: A chain of inheritance where a class inherits from another subclass.
- **Hierarchical Inheritance**: Multiple subclasses inherit from a single parent class.
- **Key Features**: Code reuse, method overriding, extensibility, and maintainability.
- **Method Overriding**: A subclass defines a method that overrides a method in the parent class.
- **Constructor Inheritance**: Subclasses can call the constructor of the parent class using `super()`.
- **Polymorphism**: A subclass object can be treated as an instance of its parent class, with the correct method being called based on the actual object type.
- **Access Modifiers**: Control the visibility of class members in inheritance (`public`, `private`, `protected`, and default).

<details>
<summary> Files </summary>
Animal.java
Employee.java
Vehicle.java
BankAccount.java
Person.java
Person.java
Vehicle.java
Course.java
Order.java
Book.java
Device.java
</details>

## Task 15: DATE: 10-02-2025

-**Encapsulation**: Ensure all sensitive fields are private and accessed through well-defined getter and setter methods. Include validation logic where applicable.<br>
-**Polymorphism**: Use abstract class references or interface references to handle objects of multiple types dynamically.<br>
-**Abstract Classes**: Use them to define a common structure and behavior while deferring specific details to subclasses.<br>
-**Interfaces**: Use them to define additional capabilities or contracts that are not tied to the class hierarchy.<br>

<details>
<summary> Files </summary>
BankingSystem.java
ECommercePlatform.java
EmployeeManagementSystem.java
HospitalManagementSystem.java
LibraryManagementSystem.java
OnlineFoodDeliverySystem.java
RideHailingApp.java
VehicleRentalSystem.java
</details>

## Task 16: DATE: 11-02-2025

**Singly Linked List**: Each node contains data and a pointer to the next node. Traversal is only possible in one direction.<br>
**Doubly Linked List**: Each node contains data, a pointer to the next node, and a pointer to the previous node. Traversal is possible in both directions.<br>
**Circular Linked List**: In a circular linked list, the last node points back to the first node, creating a loop. Traversal can continue indefinitely.<br>
<br><br>
**Head & Tail Management**: Always maintain the head (and tail in doubly and circular lists) to avoid traversing the entire list when accessing the first or last elements.<br>
**Null Checks**: Before performing operations like deletion or traversal, check if the list is empty to prevent errors.<br>
**Efficient Insertion/Deletion**: Insert at the beginning or end for O(1) time complexity. For operations in the middle, ensure proper pointer updates to maintain list integrity.<br>
**Memory Management**: Properly nullify pointers (next, prev) when deleting nodes to prevent memory leaks, especially in languages without garbage collection.<br>
**Boundary Handling**: Carefully handle edge cases like inserting/deleting at the head, tail, or middle of the list, ensuring correct pointer updates.<br>
**Avoid Infinite Loops (Circular Lists)**: Implement conditions to stop traversal after one complete cycle to avoid infinite loops.<br>

<details>
<summary> Files </summary>
CPUSchedular.java
InventoryManagement.java
LibrarySystem.java
MovieManagementSystem.java
SocialMedia.java
TaskScheduler.java
TextEditorApp.java
TicketReservationApp.java
</details>

## Task 17: DATE: 13-02-2025
**Stack**

A Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. The element inserted last is the first to be removed. It is commonly used for scenarios where elements need to be processed in reverse order of their insertion.<br>
Key Operations<br>
push(E e): Adds an element to the top of the stack.<br>
pop(): Removes and returns the top element of the stack.<br>
peek(): Retrieves the top element without removing it.<br>
isEmpty(): Checks if the stack is empty.<br>

**Queues**

A Queue is a linear data structure that follows the First In, First Out (FIFO) principle, where the element added first is the first one to be removed. It is widely used in scenarios like scheduling, buffering, and resource management.<br>
Types of Queues<br>
Simple Queue: FIFO behavior.<br>
PriorityQueue: Elements are ordered based on priority.<br>
Deque (Double-Ended Queue): Allows insertion and deletion from both ends.<br><br>
Key Operations<br>
offer(E e): Adds an element to the queue.<br>
poll(): Retrieves and removes the head of the queue.<br>
peek(): Retrieves the head without removing it.<br>
isEmpty(): Checks if the queue is empty.<br>

**HashMap**

A HashMap in Java is a part of the java.util package and is used to store key-value pairs. It provides constant-time performance for most operations like insertion, deletion, and retrieval (in the average case).<br>
Key Operations<br>
put(K key, V value): Inserts or updates a key-value pair.<br>
get(Object key): Retrieves the value for a given key.<br>
containsKey(Object key): Checks if a key exists.<br>
remove(Object key): Removes a key-value pair.<br>

<details>
<summary> Files </summary>
  CircularTour.java
  QueueusingStack.java
  SlidingWindowMaximum.java
  SortStackRecursively.java
  StockSpan.java
  CustomHashMap.java
  LongestConsecutiveSequence.java
  PairWithTargetSum.java
  TwoSum.java
  ZeroSumSubarrays.java
</details>

## Task 18: DATE: 14-02-2025

**Bubble Sort**
Bubble Sort is a simple sorting algorithm that repeatedly compares adjacent elements and swaps them if they are in the wrong order. This process continues until the entire array is sorted.

**Insertion Sort**
Insertion Sort works by building a sorted portion of the array one element at a time by picking an element and inserting it at the correct position within the sorted portion.

**Merge Sort (Divide and Conquer)**
Merge Sort follows the Divide and Conquer approach, where an array is recursively divided into two halves, sorted individually, and merged back together.

**Quick Sort (Divide and Conquer)**
Quick Sort is another Divide and Conquer algorithm that selects a pivot element, partitions the array around it, and recursively sorts the left and right sub-arrays.


<details>
<summary> Files </summary>
BubbleSort.java
CountingSort.java
HeapSort.java
InsertionSort.java
MergeSort.java
QuickSort.java
SelectionSort.java
</details>


## Task 19: DATE: 15-02-2025

**Linear Search**
Linear search is one of the simplest searching algorithms used to find a target value within a list or array. It works by checking each element in the list one by one until the target element is found or the end of the list is reached.

**Binary Search**
Binary Search is an efficient searching algorithm used to find an element in a sorted dataset. Unlike Linear Search, which checks each element one by one, Binary Search repeatedly divides the search space in half, reducing the time complexity to O(log n).

In Java, String is immutable, meaning every modification creates a new object in memory. To handle frequent string manipulations efficiently, Java provides StringBuilder and StringBuffer, which are mutable alternatives to String.

**StringBuilder**
It is mutable, meaning it modifies the same object instead of creating a new one.
Fast because it is not synchronized (no locking mechanisms).
Ideal for single-threaded applications.

**StringBuffer**
Similar to StringBuilder but synchronized, meaning it is thread-safe.
Slightly slower due to synchronization overhead.
Used in multi-threaded applications.

**Buffered Reader**
BufferedReader is a Java class in the java.io package that reads text from an input stream efficiently. It buffers the input to improve performance, making it faster than reading characters one by one.

**File Reader and Input Stream Reader**
Both FileReader and InputStreamReader are classes in the java.io package that are used to read data from files or other input streams. However, there are differences in their usage and underlying mechanisms.

**Input Stream Reader**
Converts byte streams into character streams, making it useful when dealing with input streams (like reading from a file or network socket) that provide byte data.
It is a bridge between byte streams and character streams, and it can be used with any InputStream (e.g., FileInputStream, BufferedInputStream).
Encoding: Allows specifying the character encoding (e.g., UTF-8, ISO-8859-1), which makes it more flexible than FileReader.

<details>
<summary> Files </summary>
BinarySearchFirstLast.java
CompareStringBufferStringBuilder.java
ConcatenateStrings.java
ConvertByteStreamToCharStream.java
CountWordOccurences.java
MatrixSearch.java
PeakElement.java
ReadFileLineByLine.java
ReadInputAndWriteToFile.java
RemoveDuplicates.java
ReverseString.java
RotatedSortedArray.java
SearchAndFind.java
Solution.java
Solution2.java
StringAndFileOperations.java
</details>

## Task 20: DATE: 17-02-2025

**Runtime Analysis** - Runtime analysis evaluates how an algorithm's performance (time and space) scales with input size. The goal is to determine the efficiency of an algorithm before actual implementation.
**Big-O Notation** - Big-O notation describes the upper bound of an algorithm's complexity, representing the worst-case scenario in terms of execution time and space required.
    Common Big-O Notations
      O(1) - Constant Time
      O(log N) -Logarithmic Time
      O(N) - Linear Time
      O(N log N) - Linearithmic Time
      O(N²) - Quadratic Time
      O(2^N) - Exponential Time
      O(N!) - Factorial Time

<details>
  <summary>Files</summary>
  DataStructureSearchComparison.java
  FibonacciComparison.java
  LargeFileReadingComparison.java
  SearchComparison.java
  SortingComparison.java
  StringConcatenationComparison.java
</details>

## Task 21: DATE: 18-02-2025

Java Generics allow developers to write flexible and reusable code while maintaining type safety. Generics enable classes, interfaces, and methods to operate on parameterized types, reducing runtime errors by shifting type checking to compile-time.

Wildcards in Generics

Wildcards (?) allow flexibility in specifying unknown types:
  - <?> (Unbounded wildcard)
  - <? extends T> (Upper-bounded wildcard)
  - <? super T> (Lower-bounded wildcard)

Java Generics provide a powerful way to create reusable, type-safe code. By leveraging generics, developers can build robust applications with fewer runtime errors and improved maintainability.

<details>
  <summary>Files</summary>
  MarketPlace.java
  PersonalizedMealPlan.java
  ResumeScreening.java
  SmartWareHouseSystem.java
  UniversityCourseManagement.java
</details>

## Task 22: DATE: 20-02-2025

The Java Collection Framework is a unified architecture for representing and manipulating collections of objects. It provides a set of interfaces and classes to store, retrieve, manipulate, and communicate aggregate data.

The Collection Framework Interfaces
1.Collection
2.Deque
3.List
4.Set
5.Map
6.Sorted Set
7.Sorted Map
8.Queue
9.Navigable Set

java.util →Package contains the collection classes let us to group elements in various ways . The Collection Classes also define several methods that provide easier way of working with items . These classes are important , not just for their but because many other Java methods use or return objects of these classes such as the ArrayList and HashMap classes. Collection package added to JSE 1.2 Java SE 8 has significantly increased the power and streamlined the use of collection framework.

<details>
  <summary>Files</summary>
  FrequencyCounter.java
  NthFromEnd.java
  RemoveDuplicates.java
  ReverseArrayList.java
  RotateList.java
  GroupByDepartment.java
  MapInverter.java
  MaxValueKey.java
  MergeMaps.java
  WordFrequencyCounter.java
  sample.txt
  CircularBuffer.java
  GenerateBinaryNumbers.java
  HospitalTriageSystem.java
  ReverseQueue.java
  StackUsingQueues.java
  CheckSubset.java
  CompareSets.java
  SetOperations.java
  SetToSortedList.java
  SymmetricDifference.java
</details>


## Task 23: DATE: 21-02-2025

Java provides a rich set of I/O (Input/Output) classes to read and write data. These classes are part of the java.io package and are based on the concept of streams. A stream represents a sequence of data and can be used for reading from or writing to a data source or destination.

Types of Streams
  1. File Streams
  2. Object Streams
  3. ByteArray Streams
  4. Buffered Streams
  5. Reader and Writer

<details>
  <summary>Files</summary>
    BufferedFileCopy.java
    EmployeeSerialization.java
    FileCopy.java
    FilterStreamsLowercase.java
    ImageByteArrayStream.java
    PipeStreamExample.java
    ReadLargeFile.java
    StudentDataStream.java
    UserInputToFile.java
    WordCount.java
    copy_buffered.dat
    copy_unbuffered.dat
    destination.txt
    employee.ser
    largefile.dat
    source.txt
    students.dat
    user_data.txt
</details>

## Task 24: DATE: 21-02-2025

<h1>Exception Handling in Java</h1>
  Exception handling in Java is a powerful mechanism to handle runtime errors, ensuring the smooth execution of the program. It is managed via five keywords: try, catch, finally, throw, and throws.

<h1>Try and Catch Block</h1>
  Try Block: The code that might throw an exception is placed inside the try block. If an exception occurs, it is handled by the catch block.
  Catch Block: The catch block follows the try block and catches exceptions thrown by the try block. You can have multiple catch blocks to handle different types of exceptions

<h1>Checked Exceptions in Java</h1>
  Checked exceptions are exceptions that are checked at compile-time by the Java compiler. If a method is capable of throwing a checked exception, it must either handle the exception using a try-catch block or     declare it in its method signature using the throws keyword. Failure to do so results in a compilation error.

<h1>Unchecked Exceptions in Java</h1>
  Unchecked exceptions are exceptions that are not checked at compile-time but occur at runtime. These exceptions are subclasses of RuntimeException and represent programming errors that are often avoidable,       such as logic errors or improper use of an API.
<br><br>
<strong>Finally Block</strong><br>
<i>The finally block is used to execute important code such as closing resources. It is executed whether an exception is handled or not.</i>

<h1>Java Nested Try</h1>
In Java, you can use nested try blocks to handle exceptions more granularly. This means placing one try block inside another try block, allowing you to catch and handle exceptions separately for different parts of your code. This can be useful when you have multiple operations that might throw exceptions, and you want to handle each operation's exceptions individually.
<br><br>
<strong>Throw Keyword:</strong> The throw keyword is used to explicitly throw an exception.<br>
<strong>Throws Keyword:</strong> The throws keyword is used in a method signature to declare that a method can throw one or more exceptions.
<br>
<details>
  <summary>Files</summary>
    AgeValidationExample.java
    ArrayOperationExample.java
    BankAccount.java
    DivisionExample.java
    DivisionWithFinally.java
    ExceptionPropogationProblem.java
    FileReader.java
    FileReaderExample.java
    InterestCalculator.java
    NestedTryCatchExample.java
    data.txt
</details>

## Task 25: DATE: 22-02-2025

<h1>Regex</h1><br>
Regular Expressions (Regex) are a sequence of characters defining a search pattern. They are commonly used for validations, searching, text manipulation, and data extraction.
Java provides the java.util.regex package to handle regular expressions.
<br>
Java provides two main classes to work with regex:<br>
**Pattern** → Represents a compiled regex pattern.<br>
**Matcher** → Performs operations like searching, matching, and replacing.<br>
<h1>3. Regex Metacharacters :</h1>

<i>Metacharacters are special characters with a specific meaning in regex.</i>
<br>
<h1>Regex Quantifiers :</h1>
<i>Quantifiers define how many times a character or group appears in the text.</i>
<br>

<h1>JUnit</h1><br>
JUnit is a Java unit testing framework used to write and execute automated tests. It helps developers ensure that their code functions correctly by verifying individual units (methods or classes) in an application.

<br>
<h1>JUnit Annotations</h1>
<br>
@Test - Marks a method as a test case<br>
@BeforeEach - Runs before each test method<br>
@AfterEach - Runs after each test method<br>
@BeforeAll - Runs once before all test methods (Static)<br>
@AfterAll - Runs once after all test methods (Static)<br>
@DisplayName - Sets a custom test name<br>
@Disabled - Skips a test method<br>
@RepeatedTest(n) - Runs a test multiple times<br>
@ParameterizedTest - Runs a test with different parameters<br>
@Tag - Categorizes tests for filtering<br>

## Task 26: DATE: 24-02-2025

<h1>Reflection</h1>
Reflection is a powerful feature in Java that allows us to inspect and manipulate classes, methods, fields, and constructors at runtime, even if their names are unknown at compile time.

<li> Reflection allows runtime access to classes, methods, fields, and annotations.</li>
<li> We can modify private fields, call private methods, and create objects dynamically.</li>
<li> Reflection is useful but should be used cautiously due to performance overhead.</li>

<h1>Annotations</h1><br>
Annotations are metadata added to Java code (classes, methods, fields, etc.) to provide additional information. They do not directly affect program execution but can be processed by:<br>
<li>Compilers (e.g., @Override for compile-time checks).</li><br>
<li>Runtime environments (e.g., JUnit’s @Test for test execution).</li><br>
<li>Frameworks (e.g., Spring’s @Autowired for dependency injection).</li><br>
<br>
<h2>Core Java Annotations</h2>
<li>@Override - Indicates a method is overriding a superclass method.</li><br>
<li>@Deprecated - Marks a method/class as obsolete and Triggers a compiler warning if used.</li><br>
<li>@SuppressWarnings - Suppresses compiler warnings for specific code blocks.</li><br>
<li>@FunctionalInterface - Ensures an interface has exactly one abstract method (for lambda compatibility).</li><br>
<br>
<h2>Meta-Annotations (Annotations for Annotations)</h2><br>
<li>@Retention - Specifies how long the annotation is retained:
                RetentionPolicy.SOURCE (discarded by the compiler).
                RetentionPolicy.CLASS (retained in class files, not runtime).
                RetentionPolicy.RUNTIME (accessible via reflection).
</li>
<br>
<li>@Target - Defines where the annotation can be applied: ElementType.METHOD, ElementType.TYPE, ElementType.FIELD, etc.</li><br>
<li>@Inherited - Allows subclasses to inherit the annotation from a superclass.</li><br>
<li>@Documented - Includes the annotation in generated Javadoc.</li><br>


## Task 27: DATE: 25-02-2025

CSV (Comma-Separated Values) is a simple file format used to store tabular data in plain text. Each line represents a row, and columns are separated by commas.<br>

** Reading CSV Files in Java**<br>
Java provides multiple ways to read CSV files, including:<br>
<li>Using BufferedReader (Manual Parsing)</li>
<li>Using OpenCSV Library</li>
<li>Using Apache Commons CSV</li>

** Writing CSV Files in Java**<br>
Java provides multiple ways to read CSV files, including:<br>
<li> Using FileWriter & BufferedWriter</li>
<li>Using OpenCSV </li>

**Data Validation in CSV**
<li>Ensure numeric fields contain valid numbers.</li>
<li>Check for missing or empty fields.</li>
<li>Validate email formats using regex.</li>

<details>
  <summary>Files</summary>
  CSV_Files
  CSVToObjects.java
  ConvertJSONCSV.java
  CountCSVRows.java
  DetectCSVDuplicates.java
  EncryptDecryptCSV.java
  FilterCSVRecords.java
  GenerateCSVReport.java
  MergeCSVFiles.java
  ReadCSV.java
  ReadLargeCSV.java
  SearchCSVRecords.java
  SortCSVRecords.java
  UpdateCSV.java
  ValidateCSV.java
  WriteCSV.java
</details>

## Task 28: DATE: 26-02-2025

JSON (JavaScript Object Notation) is a lightweight data format used for data exchange between servers and web applications. It is human-readable and easy to parse.
<br>
<h1>Syntax of JSON</h1><br>
A JSON object is enclosed within curly braces {} and contains key-value pairs separated by a colon :. Multiple key-value pairs are separated by a comma ,.<br>
Basic JSON Object Example :<br>
{<br>
  "name": "Example",<br>
  "age": 25,<br>
  "email": "example@example.com"<br>
}

<details>
  <summary>Files</summary>
    CarObjectToJson.java
    ConvertCSVToJSON.java
    ConvertJSONToXML.java
    ConvertListToJSONArray.java
    ConvertListToJSONArray2.java
    FilterJSON.java
    FilterJSONByAge.java
    FilterJSONExample.java
    GenerateJSONFromDB.java
    IPLCensorAnalyzer.java
    JSONCreate.java
    JsonReadFile.java
    MergeJSONObjects.java
    MergeJSONObjects2.java
    ReadJSONAndPrint.java
    ValidateEmail.java
    ValidateJSON.java
</details>
